# 0506



### Vue.js

* 사용자 인터페이스를 만들기 위한 프로그레시브 framework

* 다양한 라이브러리, 현대적인 tool로 Single Page Aplication(SPA)를 완벽히 지원한다.

  * ex) 페이스북 같은거. 필요한 페이지를 한번에, 보여줌
    * SPA단일페이지 구성, 서버로부터 처음에만 페이지 받고, 그 다음엔 동적으로 DOM 구성한다.
    * 한번 받고 난 다음부터는 페이지 새로고침 안하고 동적으로 구성
    * CSR의 형식을 따른다.

* Vue.js + Angular 의 장점을 합쳤다.

  

* CSR (밀키트 느낌)

  * Client Side Rendering
  * 최초 요청할 때 서버에서 빈 문서 응답해주고, 클라이언트에서 데이터 요청해서 데이터 받고, DOM을 렌더링 한다.
  * SSR(Server Side Rendering) 보다 초기 전송 페이지 속도는 빠른데, 서비스에 필요한 데이터를 클라이언트(브라우저)에서 추가 요청해서 재구성해야하므로, 전체적 페이지 완료 시점은 SSR보다 느리다.
  * SPA가 렌더링하는 방식이다.

  | 장점                                                         | 단점                                             |
  | ------------------------------------------------------------ | ------------------------------------------------ |
  | 서버 클라이언트 간 트래픽 감소                               | SEO(검색엔진 최적화) 문제가 발생할 가능성        |
  | 웹 애플리케이션에 필요한 모든 정적 리소스 최초 한번 다운로드 | page가 완성되어있지 않은 상태고 빈페이지인 상태, |
  | 사용자 경험 향상                                             | 검색엔진이 충분한 데이터를 받는게 어렵           |
  | 전체 페이지 다시 렌더링 X 변경되는 것만 갱신                 |                                                  |

  

* SSR (완제품 느낌)

  * Server Side Rendering

  * 서버에서 사용자한테 보여줄 페이지 모두 구성해서 보여주는 방식

  * 서버 이용해서 페이지 구성하기 때문에 클라이언트에서 구성하는 CSR보다 구성하는 속도는 늦지만 

    사용자한테 보여주는 콘텐츠 구성이 완료되는 시점을 빠르다.

| 장점                                          | 단점                                                     |
| --------------------------------------------- | -------------------------------------------------------- |
| 초기 로딩 속도 빨라서 컨텐츠 빨리 볼 수 있다. | 모든 요청에 새로고침이 되기 때문에 사용자 경험 떨어진다. |
| SEO(검색엔진 최적화)가 가능하다               | 상대적으로 요청횟수가 많아져 서버부담 大                 |



* SEO
  * Search Engine Optimization (검색 엔진 최적화)
  * 웹 페이지 검색엔진이 자료 수집, 순위를 메기는 방식에 맞게 페이지를 구성해서 검색 결과 상위에 노출되게 할 수 있도록 하는 작업
  * 인터넷 마케팅 방법 중 하나다.
  * 구글 등장 후에 검색엔진들이 컨텐츠의 신뢰도를 파악하는 기초 지표로 사용
    * 다른 사이트에서 얼마나 인용되었나
    * 결국 최종적으로 타 사이트에 인용되는 횟수를 늘리는 방향으로 최적화



* SEO 문제 대응하기

  * SSR 지원하는 SEO 대응 기술 있다.
  * Nuxt.js
    * Vue.js 응용 프로그램 만들기 위한 Framework
  * Next.js
    * React 응용 프로그램 만들기 위한 Framework

  

* SPA with SSR

  * CSR, SSR 적절히 사용

    * Django 에서 Axios 활용 좋아요/팔로우 로직 -> Server에서 완성된 HTML 제공하는 구조(SSR)

    * ㅇㅇ

      

* Vue.js 사용 이유

  * 페이지 규모는 계속 커지고 있고, 테이터 多 사용자와 상호작용도 多
  * Vanulla Js(기본 JS)만으로는 관리가 어렵다.
    * ex) 페이스북 친구 이름 변경했을 때
    * 타임라인 이름, 메시지 상 이름, 내 주소록 친구 이름
    * 그래서 페이스북이 React 개발
  * Vanilla JS
    * 한 유저가 10만개 게시글 작성 가정
    * 이 유저가 닉네임 변경 시 10만개 모두 수저오디야함
    * 모든 요소를 선택해서 이벤트 등록하고 값 변경해야함
  * Vue.js
    * DOM Data 연결되어 있으면
    * Data 변경 시 DOM 알아서 변경
    * 데이터 관리에만 신경 쓰면 됨



* ### Concepts of Vue.js

  * MVVM Pattern
    * 애플리케이션 로직을 UI로부터 분리하기 위해 설계된 디자인 패턴
    * Model
      * Plain JavaScript Objects
      * {Key:value} 자료구조 형태
      * DB는 아니고 data 형태
      * Object는 Vue Instance 내부에서 data로 사용, 값이 바뀌면 View(DOM)이 반응한다.
    * View
      * DOM (HTML)
      * data 변화에 따라 바뀌는 대상이다.
    * ViewModel
      * DOM과 data의 중개자
      * Vue Instance
      * data와 DOM에 관련된 모든 일 처리
      * ViewModel 활용해서 data를 얼마만큼 잘 처리해서 보여줄 것인지(DOM)를 고민

  

* Vue.js 시작하기

  * Django
    * url -> views -> template
    * 데이터의 흐름
  * Vue.js
    * Data 변화하면 DOM 변경
    * Data 로직 작성
    * DOM 작성

  * https://kr.vuejs.org/v2/guide/index.html 참고



* ### Basic syntax of Vue.js



* Vue instance
  * 모든 Vue 앱은 Vue 함수로 새 인스턴스 만드는 것부터 시작해야한다.
  * Vue 인스턴스 생성할 때 Options 객체를 전달해야함
    * 여러 Options 들 사용해서 원하는 동작 구현
  * Vue Instance === Vue Component(영역 같은거?)



* Options/DOM - 'el'
  * Vue 인스턴스에 연결할 때기존 DOM 엘리먼트가 필요하다
  * CSS 선택자 문자열이나 HTMLElement로 작성한다.
  * new 사용해서 인스턴스 새로 생성할 때만 사용



* Options/DOM - 'data'
  * Vue 인스턴스 데이터 객체
  * Vue 앱 상태 데이터 정의하는 곳이다. (message같은거 보내고 뭐 그런)
  * Vue template에서 interpolation( {} ) 을 통해 접근가능 
  * v-bind(연결), v-on(클릭 같은 이벤트)과 같은 디렉티브에서도 사용가능하다.
  * Vue 객체 내 다른 함수에서 this 키워드 통해 접근가능
  * 주의사항
    * 화살표 함수를 data에서 사용하면 안된다. 
    * 화살표 함수가 부모 컨텍스트를 바인딩(연결)하기 때문에, this 는 예상과 달리 Vue 인스턴스 가리키지 않는다.



* Options/Data - 'methods'
  * Vue 인스턴스에 추가할 메서드다.
  * Vue template에서 interpolation( {} ) 을 통해 접근가능 -> 함수 호출이 가능하다.
  * v-on(클릭 같은 이벤트)과 같은 디렉티브에서도 사용가능하다.
  * Vue 객체 내 다른 함수에서 this 키워드로 접근 가능하다.
  * 주의사항
    * 화살표 함수 메서드 정의하는데 사용하면 안됨. data랑 마찬가지로 사용 X
    * ㅇ화살표 함수가 부모 컨텍스트 바인딩해서 this는 vue 인스턴스 아니고 this.a는 정의 X



* this keyword in vue.js
  * dVue 함수 객체 내 vue 인스턴스 가리킨다.
  * JavaScript 함수에서 this 키워드는 다른 언어랑 다르게 동작하는 경우 있으니 주의
    * JAVA this / python self 와는 성격이 다름. <- 무조건 자기자신인데, vue.js에서 this는 위치(?)에 따라 가리키는것이 달라짐
  * 화살표 함수 사용 X
    * data
    * me????



* Interpolation(표현할 수 있는 방법)
  * Text(문자열)
    * `<span>message: {{ msg }}</span>`
  * Raw HTML(HTML 형태 그대로)
    * `<span v-html="rawHtml"></span>`
    * 이 때, html은 데이터로 작성됨
  * Attrubutes(속성)
    * dd
  * asdads
    * sad



* Directive(디렉티브)
  * v-접두사가 있는 특수 속성
  * 속성 값은 단일 JS 표현식이 된다. (v- for는 예외임)
    * 값으로 평가될 수 있는 코드
  * 표현식 값 변경 될 때 반응적으로 DOM에 적용하는 역할
    * 알아서 잘 변경됨
  * 전달인자(Arguments)
    * `:`(콜론)을 통해 전달인자 받을 수도 있다.
  * 수식어 (modifiers)
    * `.`(점)으로 표시되는 특수 접미사
    * 디렉티브를 특별한 방법으로 바인딩해야함



* v-text

  * 엘리먼트 textContent 업데이트
  * 내부적으로 interpolation({}) 문법이 v-text로 컴파일됨

* v-html

  * 엘리먼트 innerHTML 업데이트
    * XSS 공격에 취약할 수 있다.

  * 임의의 사용자로부터 입력 받는 내용은 **`절대사용금지`**

* v-show

  * 조건부 렌더링 중 하나
  * 엘리먼트는 항상 렌더링 되고 DOM에 남아있음
  * 단순 엘리먼트에 display CSS 속성을 토글한다.

* v-ifm v-else-if, v-else

  * 조건부 렌더링 중 하나

  * 조건에 따라 블록 렌더링

  * 디렉티브 표현식이 true 일때만 렌더링

  * 엘리먼트 및 포함된 디렉티브는 토글하는 동안 삭제되고 다시 작성된다.

  * false -> 화면에서 아예 삭제하고, true -> 다시 그린다(작성).

  * v-else-if 사용할 때 무조건 v-if 다음에 써야함 / 사이에 뭐 들어가면 작동 X

    * ````
      ex)
      <div v-if="myType === 'A'">A</div>
      <div v-else-if="myType === 'B'">B</div>
      <div v-else-if="myType === 'C'">C</div>
      <div v-else>Not A/B/C</div>
      ````



* v-show (Expensive - initial load / cheap - toggle)
  * CSS display 속성을 hidden으로 만들어서 toggle함.
  * 실제로 렌더링 되는데, 눈에서 보이지 않는 것이기 때문에, 딱 1번만 렌더링이 되는 경우라면 v-if에 비해 상대적으로 렌더링 비용 높다.
  * 근데 자주 변경되는 요소라면, 한번 렌더링 된 이후부터 보여주는지에 대한 여부만 판단하면 되서 토글 비용이 적다.
* v-if (Cheap - initial load, expensive - toggle)
  * 전달인자가 false인 경우 렌더링 안됨
  * 화면에서 보이지 않을 뿐만 아니라, 렌더링 자체가 안되는거라서 렌더링 비용 낮다.
  * 근데 자주 변경되는 요소는 계속 다시 렌더링 해야하기 때문에 비용 증가 가능성



* v-for
  * 원본 데이터 기반으로 엘리먼트 or 템플릿 블록 여러번 렌더링
  * 파이썬이랑 동일하게 item in items 구문 사용
  * item 위치의 변수를 각 요소에서 사용할 수 있다
  * v-for 사용 시 반드시 key 속성을 각 요소에 작성해야한다.
  * https://kr.vuejs.org/v2/style-guide/#v-for-%EC%97%90-key-%EC%A7%80%EC%A0%95-%ED%95%84%EC%88%98 참고
  * v-if  함께 사용하는 경우 v-for 가 v-if 보다 순위가 앞선다. 근데 같이 사용하지 마라 / 따로 분리해서 사용하도록



* v-on 
  * 이벤트 리스너 달아주는거
  * 이벤트 유형은 전달인자로 표시한다
  * v-on 줄여서 @로 쓰기도 함



* v-bind
  * HTML 요소 속성에 Vue의 상태 데이터 값으로 할당
  * Object 형태로 사용하면 value가 true인 key가 class 바인딩 값으로 할당
  * 약어
    * `:` 붙여서 함
    * v-bind:href -> :href



* v-model

  * HTML form 요소의 값과 data를 양방향 바인딩 ( Input, textarea, select) 에 한정
  * 수식어
    * .lazy
      * input 대신에 change 이벤트 후 동기화
    * .number
      * 문자열 숫자로 변경해준다.
    * .trim
      * 입력에 대해 공백제거 해준다.

  

* Options/Data - 'computed'

  * 데이터 기반으로 계산된 속성
  * 함수 형태로 정의하지만, 함수가 아니라 함수 반환 값이 바인딩(연결) 된다.
  * 종속된 대상 따라 저장(캐싱) 된다.
  * 종속된 대상 변경될 때만 함수 실행 -> 외부에서 정의된 함수 들어와서 변할 때 마다(계산) 실행되서 계산되어진다.
  * Date.now()처럼 아무 곳에도 의존 하지 않는 computed 속성은 절대 업데이트 안됨
  * 반드시 반환값 존재!!!!해야함

* computed & method
  * computed 대신 methods에 함수 정의도 가능
    * 결과에 대한 접근방식을 두가지 다 동일하다.
  * 차이점이 있자면 computed는 대상(변경되는) 에 따라 저장이 된다.



* Options/Data - 'watch'

  * 데이터 감시, 변화 일어날 때 실행되는 함수다.

  * ```javascript
    watch: { 
        지켜볼 data명: function (변경된 값(new), 변경전 값(old)) {
            
        }
    }
    ```

  

* computed & watch -> 차이점 꼭 알아둘것

  * computed
    * 최종 결과가 무조건 값이어야함
    * 특정 공식을 거쳐서 값으로 만들어져야함
    * 값이기 때문에 선언형 프로그래밍 방식이다.
  * watch
    * 최종 결과가 값이 아닌, 동작시키는것
    * 데이터 변화상황에 맞춰 다른 데이터 변경시켜야 할 때 사용
    * 데이터 바뀌면 이런 함수를 실행해라 -> 명령형 프로그래밍 방식



* Options/Assets - 'filters'
  * 텍스트 형식화를 적용할 수 있다.
  * {} 혹은 v-bind 사용할 때 사용할 수 있다.
  * 필터는 JS 표현식 마지막에 `|` 와 할께 추가되어야한다.
  * 체이닝을 할 수 있다.



* Lifecycle Hooks
  * 각 Vue 인스턴스는 생성될 때 초기화 단계 거친다.
    * 특정 시점에 특정 동작하게 하는 함수